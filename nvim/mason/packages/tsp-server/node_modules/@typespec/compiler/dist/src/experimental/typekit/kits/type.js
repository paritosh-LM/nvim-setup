import { ignoreDiagnostics } from "../../../core/diagnostics.js";
import { getDiscriminatedUnion } from "../../../core/helpers/discriminator-utils.js";
import { getLocationContext } from "../../../core/helpers/location-context.js";
import { getDiscriminator, getMaxItems, getMaxLength, getMaxValue, getMaxValueExclusive, getMinItems, getMinLength, getMinValue, getMinValueExclusive, } from "../../../core/intrinsic-type-state.js";
import { isErrorType, isNeverType } from "../../../core/type-utils.js";
import { getDoc, getSummary } from "../../../lib/decorators.js";
import { resolveEncodedName } from "../../../lib/encoded-names.js";
import { defineKit } from "../define-kit.js";
import { $ } from "../index.js";
import { copyMap } from "../utils.js";
import { getPlausibleName } from "../utils/get-plausible-name.js";
defineKit({
    type: {
        finishType(type) {
            this.program.checker.finishType(type);
        },
        clone(type) {
            let clone;
            switch (type.kind) {
                case "Model":
                    clone = this.program.checker.createType({
                        ...type,
                        decorators: [...type.decorators],
                        derivedModels: [...type.derivedModels],
                        sourceModels: type.sourceModels.map((x) => ({ ...x })),
                        properties: copyMap(type.properties),
                        indexer: type.indexer ? { ...type.indexer } : undefined,
                    });
                    break;
                case "Union":
                    clone = this.program.checker.createType({
                        ...type,
                        decorators: [...type.decorators],
                        variants: copyMap(type.variants),
                        get options() {
                            return Array.from(this.variants.values()).map((v) => v.type);
                        },
                    });
                    break;
                case "Interface":
                    clone = this.program.checker.createType({
                        ...type,
                        decorators: [...type.decorators],
                        operations: copyMap(type.operations),
                    });
                    break;
                case "Enum":
                    clone = this.program.checker.createType({
                        ...type,
                        decorators: [...type.decorators],
                        members: copyMap(type.members),
                    });
                    break;
                case "Namespace":
                    clone = this.program.checker.createType({
                        ...type,
                        decorators: [...type.decorators],
                        instantiationParameters: type.instantiationParameters
                            ? [...type.instantiationParameters]
                            : undefined,
                        models: copyMap(type.models),
                        decoratorDeclarations: copyMap(type.decoratorDeclarations),
                        enums: copyMap(type.enums),
                        unions: copyMap(type.unions),
                        operations: copyMap(type.operations),
                        interfaces: copyMap(type.interfaces),
                        namespaces: copyMap(type.namespaces),
                        scalars: copyMap(type.scalars),
                    });
                    break;
                case "Scalar":
                    clone = this.program.checker.createType({
                        ...type,
                        decorators: [...type.decorators],
                        derivedScalars: [...type.derivedScalars],
                        constructors: copyMap(type.constructors),
                    });
                    break;
                default:
                    clone = this.program.checker.createType({
                        ...type,
                        ...("decorators" in type ? { decorators: [...type.decorators] } : {}),
                    });
                    break;
            }
            this.realm.addType(clone);
            return clone;
        },
        isError(type) {
            return isErrorType(type);
        },
        getEncodedName(type, encoding) {
            return resolveEncodedName(this.program, type, encoding);
        },
        getSummary(type) {
            return getSummary(this.program, type);
        },
        getDoc(type) {
            return getDoc(this.program, type);
        },
        getPlausibleName(type) {
            return getPlausibleName(type);
        },
        getDiscriminator(type) {
            let discriminator;
            if ($.model.is(type)) {
                discriminator = getDiscriminator(this.program, type);
            }
            else {
                const unionDiscriminator = ignoreDiagnostics(getDiscriminatedUnion(this.program, type));
                const propertyName = unionDiscriminator?.options.discriminatorPropertyName;
                if (propertyName) {
                    discriminator = { propertyName };
                }
            }
            return discriminator;
        },
        maxValue(type) {
            return getMaxValue(this.program, type);
        },
        minValue(type) {
            return getMinValue(this.program, type);
        },
        maxLength(type) {
            return getMaxLength(this.program, type);
        },
        minLength(type) {
            return getMinLength(this.program, type);
        },
        maxItems(type) {
            return getMaxItems(this.program, type);
        },
        maxValueExclusive(type) {
            return getMaxValueExclusive(this.program, type);
        },
        minValueExclusive(type) {
            return getMinValueExclusive(this.program, type);
        },
        minItems(type) {
            return getMinItems(this.program, type);
        },
        isNever(type) {
            return isNeverType(type);
        },
        isUserDefined(type) {
            return getLocationContext(this.program, type).type === "project";
        },
    },
});
//# sourceMappingURL=type.js.map